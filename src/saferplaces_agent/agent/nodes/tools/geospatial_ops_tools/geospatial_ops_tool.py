import os
import base64
import datetime
from dateutil import relativedelta
from enum import Enum
import requests

from typing import Optional, Union, List, Dict, Any
from pydantic import BaseModel, Field, AliasChoices, field_validator, model_validator

from langchain_core.callbacks import (
    AsyncCallbackManagerForToolRun,
    CallbackManagerForToolRun,
)

from agent import utils
from agent import names as N
from agent.nodes.base import BaseAgentTool


class GeospatialOpsInputSchema(BaseModel):
    """
    Inputs for the Geospatial Operation Tool.

    This tool interprets a user prompt that requests geospatial operations on layers.
    Capabilities include:
    - Responding with geospatial knowledge (e.g., bounding box of a known city).
    - Performing operations on available layers (intersections, within, union, dissolve, etc.).
    - Producing outputs with reference to a new layer to add to the map.
    
    The tool activates only if the prompt implies a geospatial operation.
    """

    prompt: str = Field(
        ...,
        title="User Prompt",
        description=(
            "The user request describing the geospatial operation to perform. "
            "Can involve queries on known geographies or operations on existing layers."
        ),
        examples=[
            "Give me the bounding box of Rome",
            "Find all buildings within the bounding box of Rome",
        ],
    )

    class Config:
        # Impedisci campi sconosciuti; abilita uso dei nomi/alias indifferentemente
        extra = "forbid"
        populate_by_name = True
        




# DOC: This is a demo tool to retrieve weather data.
class GeospatialOpsTool(BaseAgentTool):
        
    
    # DOC: Initialize the tool with a name, description and args_schema
    def __init__(self, **kwargs):
        super().__init__(
            name = N.GEOSPATIAL_OPS_TOOL,
            description =  """The Geospatial Operation Tool interprets natural language prompts requesting geospatial operations.
            It can respond using geographic knowledge (e.g., bounding boxes of known cities) or by analyzing available vector layers,
            performing spatial filters, intersections, aggregations, and geometry-based calculations.
            The tool activates only if the prompt implies a geospatial operation and produces outputs such as geometries, GeoJSON, or summary statistics.
            Code to perform operations is generated by the LLM but executed in a safe and controlled environment""",
            args_schema = GeospatialOpsInputSchema,
            **kwargs
        )
        self.execution_confirmed = True
        self.output_confirmed = False
        
    
    # DOC: Validation rules ( i.e.: valid init and lead time ... ) 
    def _set_args_validation_rules(self) -> dict:
        return dict()
        
    
    # DOC: Inference rules ( i.e.: from location name to bbox ... )
    def _set_args_inference_rules(self) -> dict:
        return dict()
        
    
    # DOC: Execute the tool → Build notebook, write it to a file and return the path to the notebook and the zarr output file
    def _execute(
        self,
        /,
        **kwargs: Any,  # dict[str, Any] = None,
    ): 
        
        def describe_layer_registry():
            """Describe the layers available in the registry."""
            layers = self.graph_state.get('layer_registry', [])
            if not layers:
                return "No layers available."
            layer_descriptions = []
            for layer in layers:
                layer_description = []
                layer_description.extend([
                    f"Layer: {layer['name']}",
                    f"- type: {layer['type']}",
                    f"- src: {layer['src']}"
                ])
                layer_descriptions.append('\n'.join(layer_description))
            return '\n\n'.join(layer_descriptions)
                
        print('\n\n' + '-'*80 + '\n')
        print(f'layers: {self.graph_state.get("layer_registry", [])}')
        print('\n')
        print(f'kwargs: {kwargs}')
        print('\n' + '-'*80 + '\n')    
        
        output = utils.ask_llm(
            role='system',
            message=f"""You are a Python code generator specialized in geospatial operations. 

            Your task: Given a user request describing a geospatial data operation, output only valid Python code that produces the requested data. 

            Constraints:

            1. Always respond with Python code only. Do NOT include explanations, text, or commentary.  
            2. You may use only the following libraries: geopandas, shapely, pandas, fiona, rasterio, pyproj, numpy. No other libraries.  
            3. You can produce results based on:  
            a) Your internal geographic knowledge (e.g., bounding boxes of known cities, coordinates of countries).  
            b) Provided vector layers, given as a local path or S3 URL.  

            Instructions:

            - Name the resulting variable `result`.  
            - The code should be self-contained and executable, assuming the required libraries are imported and any input layers are accessible.  
            - If the user request requires working with a layer, assume it is provided as a variable `layer` (loaded with geopandas.read_file or similar) or as a file path / S3 URL string.  
            - Use proper geospatial operations: intersections, within, filtering by bbox, or attribute-based selections.  
            - Produce only data, e.g., a GeoDataFrame, shapely geometry, or a dictionary summarizing geometry stats. Do NOT print, log, or output anything else.  
            - Do not perform file system operations outside of reading allowed layers.  
            - Do not import os, sys, subprocess, or any unsafe modules.  

            User request:
            "{kwargs['prompt']}"
            
            You have access to the following layers:
            {describe_layer_registry()}
            """,
            eval_output=False
        )
        
        tool_response = {
            # TODO: Geospatial ops layer info dict
            # TODO: Map actions to be executed by the frontend (new-layer)
            'generated_code': output
        }
        
        print('\n', '-'*80, '\n')
        
        return tool_response
        
    
    # DOC: Back to a consisent state
    def _on_tool_end(self):
        self.execution_confirmed = True
        self.output_confirmed = False
        
    
    # DOC: Try running AgentTool → Will check required, validity and inference over arguments thatn call and return _execute()
    def _run(
        self, 
        /,
        **kwargs: Any, # dict[str, Any] = None,
    ) -> dict:
        
        run_manager: Optional[CallbackManagerForToolRun] = kwargs.pop("run_manager", None)
        return super()._run(
            tool_args = kwargs,
            run_manager = run_manager
        )